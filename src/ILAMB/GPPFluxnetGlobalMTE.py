from netCDF4 import Dataset
import numpy as np
import pylab as plt
import ilamblib as il
from constants import convert
from Post import GlobalPlot

class GPPFluxnetGlobalMTE():
    """Confront models with the gross primary production (GPP) product
    generated by Fluxnet MTE.
    """
    def __init__(self):
        self.name = "GPPFluxnetGlobalMTE"
        self.path = "/chrysaor/ILAMB/gpp/FLUXNET-MTE/derived/"
        #self.path = "/home/ncf/data/ILAMB/DATA/FLUXNET-MTE/derived/"
        self.nlat = 360
        self.nlon = 720

    def getData(self,initial_time=-1e20,final_time=1e20,output_unit=""):
        """Retrieves the confrontation data on the desired time frame and in
        the desired unit.

        Parameters
        ----------
        initial_time : float, optional
            include model results occurring after this time
        final_time : float, optional
            include model results occurring before this time
        output_unit : string, optional
            if specified, will try to convert the units of the variable 
            extract to these units given (see convert in ILAMB.constants)

        Returns
        -------
        t : numpy.ndarray
            a 1D array of times in days since 00:00:00 1/1/1850
        var : numpy.ma.core.MaskedArray
            an array of the extracted variable
        unit : string
            a description of the extracted unit
        """
        # why are these stored as separate netCDF files? Isn't I/O
        # latency worse if these are broken up and I have to build a
        # composite?
        y0   = max(int(initial_time/365.),1982)
        yf   = min(int(  final_time/365.),2005)
        ny   = yf-y0+1; nm = 12*ny
        t    = np.zeros(nm)
        # FIX: if you ever only wanted some of the MTE data, this would fail
        var  = np.ma.zeros((nm,self.nlat,self.nlon))
        unit = ""
        lat,lon = None,None
        for y in range(ny):
            yr = y+1982
            for m in range(12):
                ind   = 12*y+m
                fname = "%s%d/gpp_0.5x0.5_%d%02d.nc" % (self.path,yr,yr,m+1)
                f = Dataset(fname)
                v = f.variables["gpp"]
                t  [ind    ] = v.time
                var[ind,...] = v[...]
                unit = v.units
                if lat is None:
                    lat = f.variables["lat"][...]
                    lon = f.variables["lon"][...]

        # if you asked for a specific unit, try to convert
        # FIX: migrate this to ilamblib
        unit = unit.lower()
        if output_unit is not "":
            try:
                var *= convert["gpp"][output_unit][unit]
                unit = output_unit
            except:
                raise il.UnknownUnit("Variable is in units of [%s], you asked for [%s] but I do not know how to convert" % (unit,output_unit))
        return t,var,unit,lat,lon

    def confront(self,m):
        r"""Confronts the input model with the observational data.

        Parameters
        ----------
        m : ILAMB.ModelResult.ModelResult
            the model results                  

        Returns
        -------
        cdata : dictionary                  
            contains all outputs/metrics

        Notes
        -----
        The dictionary key "metric" will return a dictionary which
        contains the analysis results. For this confrontation we
        include the following quantities in the analysis. We define
        :math:`gpp(\mathbf{x},t)` as the mean monthly gross primary
        productivity as a function of space (:math:`\mathbf{x}`) and
        time (:math:`t`) given in units of "g m-2 s-1". For
        convenience, we will define here a spatially integrated
        quantity as well,
        
        .. math:: \overline{gpp}(t) = \int_A gpp(\mathbf{x},t)\ dA

        where :math:`A` refers to the area of interest.

        "PeriodMean" : float
            The mean gross primary productivity for the globe
            averaged over the time period, or

            .. math:: \frac{\int_{t_0}^{t_f} \overline{gpp}(t)\ dt}{t_f-t_0}

            in units of "g/s"
        "MonthlyMeanBias" : float
            The bias of the spatially integrated monthly mean model
            result compared to that of the observational data in units
            of "g/s"
        "MonthlyMeanRMSE" : float
            The RMSE of the spatially integrated monthly mean model
            result compared to that of the observational data in units
            of "g/s"
        "PhaseChange" : float
            The mean time difference in the annual peaks of gross
            primary production in the model result compared to the
            observational data. The annual peak time is written as
            :math:`t_{\text{peak}}(\mathbf{x},t_a)` where :math:`t_a`
            refers to the year. Then we can compute a temporally
            averaged quantity,

            .. math:: \bar{t}_{\text{peak}}(\mathbf{x}) = \frac{1}{t_{af}-t_{a0}}\int_{t_{a0}}^{t_{af}} t_{\text{peak}}(\mathbf{x},t)\ dt

            Then the phase change is given as the difference of peak
            times of the model relative to the observations,
            integrated over the area of interest, or

            .. math:: \frac{1}{A} \int_A  \left(\bar{t}_{\text{peak}}^{\text{model}}(\mathbf{x}) - \bar{t}_{\text{peak}}^{\text{obs}}(\mathbf{x})\right)\ dA

        """
        # if the model data doesn't have areas or land fractions, we
        # can't do area studies
        if m.cell_areas is None or m.land_fraction is None: 
            raise il.AreasNotInModel("The %s model cannot perform the %s confrontation because it does not have either areas or land fractions" % (m.name,self.name))

        # get confrontation data
        to,vo,unit,lat,lon = self.getData(output_unit="g m-2 s-1")

        # time limits for this confrontation, with a little padding to
        # account for differences in monthly time representations
        t0,tf = to.min()-5,to.max()+5

        # extract the time, variable, and unit of the model result
        tm,vm,um = m.extractTimeSeries("gpp",initial_time=t0,final_time=tf,
                                       output_unit="g m-2 s-1")

        # sign conversions vary, if all values are non-positive, flip signs
        if (vm>0).sum() == 0: vm *= -1 

        # not all models properly mask out oceans, this will make analysis faster
        vm = np.ma.masked_where((vm.mask+np.abs(vm)<1e-15)>0,vm,copy=False)

        # update time limits, might be less model data than observations
        t0,tf  = tm.min(),tm.max()
        ndays  = tf-t0
        nyears = ndays/365.

        # observation integration
        vohat = il.TemporallyIntegratedTimeSeries(to,vo)          # [g m-2]
        vobar = il.SpatiallyIntegratedTimeSeries(vo,np.ones(vo.shape[1:])) # [g s-1]
        votot = il.TemporallyIntegratedTimeSeries(to,vobar)       # [g    ]

        fig = plt.figure(figsize=(12,5))
        ax  = fig.add_axes([0.06,0.025,0.9,0.965])
        GlobalPlot(lat,lon,vohat/(nyears*365.))
        fig.savefig("gpp.png")

        # model integration
        vmhat = il.TemporallyIntegratedTimeSeries(tm,vm)          # [g m-2]
        vmbar = il.SpatiallyIntegratedTimeSeries(vm,m.land_areas) # [g s-1]
        vmtot = il.TemporallyIntegratedTimeSeries(tm,vmbar)       # [g    ]

        fig = plt.figure(figsize=(12,5))
        ax  = fig.add_axes([0.06,0.025,0.9,0.965])
        GlobalPlot(m.lat,m.lon,vmhat/(nyears*365.))
        fig.savefig("gpp%s.png" % m.name)

        # populate dictionary to return
        cdata = {}
        
        # put the observational data and manipulations here
        cdata["obs"] = {} 
        cdata["obs"]["t"]    = to
        cdata["obs"]["lat"]  = lat
        cdata["obs"]["lon"]  = lon
        cdata["obs"]["vhat"] = vohat
        cdata["obs"]["vbar"] = vobar

        # put the extracted model data and manipulations here
        cdata["model"] = {} 
        cdata["model"]["t"]    = tm
        cdata["model"]["vhat"] = vmhat
        cdata["model"]["vbar"] = vmbar

        # compute metrics
        metric = {}
        metric["PeriodMean"] = {}
        metric["PeriodMean"]["var"]  = vmtot*1e-15/nyears
        metric["PeriodMean"]["unit"] = "Pg yr-1"

        cdata["metric"] = metric
        return cdata

    def plot(self,lat,lon,var):
        fig = plt.figure(figsize=(12,5))
        ax  = fig.add_axes([0.06,0.025,0.9,0.965])
        ax.set_title("Period Mean Gross Primary Production (GPP) $g/(m^2 day)$")
        GlobalPlot(lat,lon,var,ax=ax)
        fig.savefig("%s.png" % self.name)
        

    def post(self,m):
        if "GPPFluxnetGlobalMTE" is not m.confrontations.keys(): return
        return
        
