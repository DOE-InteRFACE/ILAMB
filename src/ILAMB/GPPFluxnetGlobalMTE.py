from netCDF4 import Dataset
import numpy as np
import pylab as plt
import ilamblib as il
from constants import convert,spd
import Post as post
import os
from Variable import Variable

class GPPFluxnetGlobalMTE():
    """Confront models with the gross primary productivity (GPP) product
    generated by Fluxnet MTE.
    """
    def __init__(self):
        self.name = "GPPFluxnetGlobalMTE"
        self.path = os.environ["ILAMB_ROOT"] + "/DATA/gpp/FLUXNET-MTE/derived/"
        try:
            os.stat(self.path)
        except:
            msg  = "I am looking for data for the %s confrontation here\n\n" % self.name
            msg += "%s\n\nbut I cannot find it. " % self.path
            msg += "Did you download the data? Have you set the ILAMB_ROOT envronment variable?"
            raise il.MisplacedData(msg)
        self.data = {}
        self.regions = ["global","amazon"]
        self.output_path = "_build/GPPFluxnetGlobalMTE"
        dirs = self.output_path.split("/")
        for i,d in enumerate(dirs):
            dname = "/".join(dirs[:(i+1)])
            if not os.path.isdir(dname): os.mkdir(dname)

    def getData(self,output_unit=None):
        """Retrieves the confrontation data in the desired unit.

        Parameters
        ----------
        output_unit : string, optional
            if specified, will try to convert the units of the variable
            extract to these units given (see convert in ILAMB.constants)

        Returns
        -------
        var : ILAMB.Variable.Variable
            the requested variable
        """
        t,var,unit,lat,lon = il.ExtractTimeSeries("%s/gpp.nc" % self.path,"gpp")
        if output_unit is not None:
            try:
                var *= convert["gpp"][output_unit][unit]
                unit = output_unit
            except:
                msg  = "The gpp variable is in units of [%s]. " % unit
                msg += "You asked for units of [%s] but I do not know how to convert" % output_unit
                raise il.UnknownUnit(msg)
        return Variable(var,unit,time=t,lat=lat,lon=lon,name="gpp")

    def confront(self,m):
        r"""Confronts the input model with the observational data.

        Parameters
        ----------
        m : ILAMB.ModelResult.ModelResult
            the model results
        """
        # We will put confrontation data in this dictionary
        cdata = {}

        # If the model data doesn't have both cell areas and land
        # fractions, we can't do area integrations
        if m.cell_areas is None or m.land_fraction is None:
            msg  = "The %s model cannot perform the %s confrontation " % (m.name,self.name)
            msg += "because it does not have either areas or land fractions"
            raise il.AreasNotInModel(msg)

        # get the observational data
        obs_gpp = self.getData(output_unit="g m-2 s-1")

        # time limits for this confrontation (with a little padding)
        t0,tf = obs_gpp.time.min()-7,obs_gpp.time.max()+7
        ndays = tf-t0

        # get the model data
        mod_gpp = m.extractTimeSeries("gpp",initial_time=t0,final_time=tf,
                                      output_unit="g m-2 s-1")
        
        # ensure that oceans are properly masked
        mod_gpp.data = np.ma.masked_array(mod_gpp.data,mask=mod_gpp.data.mask+(m.land_fraction<1e-2)[np.newaxis,:,:],copy=False)

        # open a netCDF4 dataset for dumping confrontation information
        f = Dataset("%s/%s_%s.nc" % (self.output_path,self.name,m.name),mode="w")

        # integrate in time, independent of regions
        if self.data.has_key("timeint_gpp"):
            obs_timeint_gpp          = self.data["timeint_gpp"]
        else:
            obs_timeint_gpp          = obs_gpp.integrateInTime()
            self.data["timeint_gpp"] = obs_timeint_gpp
            self.data["GppMax"]      = obs_timeint_gpp.data.max()
            self.data["BiasMaxMag"]  = 0
        mod_timeint_gpp      = mod_gpp.integrateInTime()
        self.data["GppMax"]  = max(self.data["GppMax"],mod_timeint_gpp.data.max())
        cdata["timeint_gpp"] = mod_timeint_gpp
        mod_timeint_gpp.toNetCDF4(f)

        # diff map of the time integrated gpp
        bias = obs_timeint_gpp.spatialDifference(mod_timeint_gpp)
        self.data["BiasMaxMag"]   = max(self.data["BiasMaxMag"],np.abs(bias.data).max())
        cdata["timeint_bias_gpp"] = bias

        # regional analysis
        cdata    ["spaceint_gpp"] = {}
        cdata    ["cycle_gpp"   ] = {}
        self.data["spaceint_gpp"] = {}
        self.data["cycle_gpp"   ] = {}
        for region in self.regions:
            
            # integrate in space
            if self.data["spaceint_gpp"].has_key(region):
                obs_spaceint_gpp = self.data["spaceint_gpp"][region]
            else:
                obs_spaceint_gpp = obs_gpp.integrateInSpace(region=region).convert("Pg y-1")
                self.data["spaceint_gpp"][region] = obs_spaceint_gpp 
            mod_spaceint_gpp = mod_gpp.integrateInSpace(region=region).convert("Pg y-1")
            cdata["spaceint_gpp"][region] = mod_spaceint_gpp

            # metrics
            metrics = {}
            metrics["bias"      ] = obs_spaceint_gpp.bias(mod_spaceint_gpp)
            metrics["bias_score"] = obs_spaceint_gpp.bias(mod_spaceint_gpp,normalize="score")
            metrics["rmse"      ] = obs_spaceint_gpp.RMSE(mod_spaceint_gpp)
            metrics["rmse_score"] = obs_spaceint_gpp.RMSE(mod_spaceint_gpp,normalize="score")

            # dump to file
            mod_spaceint_gpp.toNetCDF4(f,attributes=metrics)

            # annual cycle
            if self.data["cycle_gpp"].has_key(region):
                obs_cycle_gpp = self.data["cycle_gpp"][region]
            else:
                obs_cycle_gpp,obs_tmax,obs_tmaxstd = obs_spaceint_gpp.annualCycle()
                self.data["cycle_gpp"][region] = obs_cycle_gpp 
            mod_cycle_gpp,mod_tmax,mod_tmaxstd = mod_spaceint_gpp.annualCycle()
            cdata["cycle_gpp"][region] = mod_cycle_gpp

        # phase
        if self.data.has_key("phase_gpp"):
            obs_phase_gpp = self.data["phase_gpp"]
        else:
            obs_phase_gpp = obs_gpp.phase()
            self.data["phase_gpp"] = obs_phase_gpp    
        mod_phase_gpp = mod_gpp.phase()
        cdata["phase_gpp"] = mod_phase_gpp

        f.close()
        return cdata

    def plot(self,M):

        print self.data["GppMax"],self.data["BiasMaxMag"]

        for region in self.regions:            

            # benchmark time integrated mean
            fig   = plt.figure(figsize=(6.8,2.8))
            ax    = fig.add_axes([0.06,0.025,0.88,0.965])
            self.data["timeint_gpp"].plot(ax,region=region,vmin=0,vmax=self.data["GppMax"],cmap="Greens")
            fig.savefig("%s/%s_Benchmark_%s_timeint.png" % (self.output_path,self.name,region))
            plt.close()

            # benchmark phase info
            fig   = plt.figure(figsize=(6.8,2.8))
            ax    = fig.add_axes([0.06,0.025,0.88,0.965])
            self.data["phase_gpp"].plot(ax,region=region,cmap="jet")
            fig.savefig("%s/%s_Benchmark_%s_phase.png" % (self.output_path,self.name,region))
            plt.close()

        for m in M:
            if not m.confrontations.has_key(self.name): continue
            data  = m.confrontations[self.name]
            for region in self.regions:

                # model time integrated mean
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                data["timeint_gpp"].plot(ax,region=region,vmin=0,vmax=self.data["GppMax"],cmap="Greens")
                fig.savefig("%s/%s_%s_%s_timeint.png" % (self.output_path,self.name,m.name,region))
                plt.close()

                # bias of time integrated mean
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                data["timeint_bias_gpp"].plot(ax,region=region,vmin=-self.data["BiasMaxMag"],
                                              vmax=self.data["BiasMaxMag"],cmap="seismic")
                fig.savefig("%s/%s_%s_%s_bias.png" % (self.output_path,self.name,m.name,region))
                plt.close()

                # model space integrated mean compared to benchmark
                fig = plt.figure(figsize=(6.8,2.8*0.8))
                ax  = fig.add_axes([0.06,0.025,0.88,0.965])
                self.data["spaceint_gpp"][region].plot(ax,lw=2,alpha=0.25,color='k',label="Obs")
                data["spaceint_gpp"][region].plot(ax,color=m.color,label=m.name)
                ax.set_xlabel("Year")
                ax.set_ylabel(data["spaceint_gpp"][region].unit)
                handles, labels = ax.get_legend_handles_labels()
                lgd = ax.legend(handles, labels, ncol=2, loc='upper center', bbox_to_anchor=(0.5,1.2))
                fig.savefig("%s/%s_%s_%s_spaceint.png" % (self.output_path,self.name,m.name,region),
                            bbox_extra_artists=(lgd,), bbox_inches='tight')
                plt.close()

                # model annual cycle compared to benchmark
                fig = plt.figure(figsize=(6.8,2.8*0.8))
                ax  = fig.add_axes([0.06,0.025,0.88,0.965])
                self.data["cycle_gpp"][region].plot(ax,lw=2,alpha=0.25,color='k',label="Obs")
                data["cycle_gpp"][region].plot(ax,color=m.color,label=m.name)
                ax.set_xlim(1850.,11./365.+1850)
                ax.set_xticks(np.arange(12)/365.+1850)
                ax.set_xticklabels(["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"])
                ax.set_ylabel(data["cycle_gpp"][region].unit)
                handles, labels = ax.get_legend_handles_labels()
                lgd = ax.legend(handles, labels, ncol=2, loc='upper center', bbox_to_anchor=(0.5,1.2))
                fig.savefig("%s/%s_%s_%s_cycle.png" % (self.output_path,self.name,m.name,region),
                            bbox_extra_artists=(lgd,), bbox_inches='tight')
                plt.close()

                # model phase info
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                data["phase_gpp"].plot(ax,region=region,cmap="jet")
                fig.savefig("%s/%s_%s_%s_phase.png" % (self.output_path,self.name,m.name,region))
                plt.close()
