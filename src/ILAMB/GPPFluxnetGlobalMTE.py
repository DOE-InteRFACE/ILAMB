from netCDF4 import Dataset
import numpy as np
import pylab as plt
import ilamblib as il
from constants import convert,spd,mid_months
import Post as post
import os,glob
from Variable import Variable,FromNetCDF4

class GPPFluxnetGlobalMTE():
    """Confront models with the gross primary productivity (GPP) product
    generated by Fluxnet MTE.
    """
    def __init__(self):
        self.name = "GPPFluxnetGlobalMTE"
        self.path = os.environ["ILAMB_ROOT"] + "/DATA/gpp/FLUXNET-MTE/derived/"
        try:
            os.stat(self.path)
        except:
            msg  = "I am looking for data for the %s confrontation here\n\n" % self.name
            msg += "%s\n\nbut I cannot find it. " % self.path
            msg += "Did you download the data? Have you set the ILAMB_ROOT envronment variable?"
            raise il.MisplacedData(msg)
        self.data = {}
        self.regions = ["global","amazon"]

        # build output path if not already built
        self.output_path = "_build/GPPFluxnetGlobalMTE"
        dirs = self.output_path.split("/")
        for i,d in enumerate(dirs):
            dname = "/".join(dirs[:(i+1)])
            if not os.path.isdir(dname): os.mkdir(dname)

        # somewhat complicated layout designation for HTML output pages
        self.layout = []
        self.layout.append({"name" :"Temporally integrated period mean",
                            "plots":{"timeint" :["MEAN",True],
                                     "bias"    :["BIAS",True]}})
        self.layout.append({"name" :"Spatially integrated period mean",
                            "plots":{"spaceint":["MEAN",False]}})
        self.layout.append({"name" :"Annual cycle",
                            "plots":{"cycle"    :["CYCLE",False],
                                     "compcycle":["CYCLE",False]}})
        self.layout.append({"name" :"Phase",
                            "plots":{"phase"   :["PHASE",True],
                                     "shift"   :["SHIFT",True]}})

    def getData(self,output_unit=None):
        """Retrieves the confrontation data in the desired unit.

        Parameters
        ----------
        output_unit : string, optional
            if specified, will try to convert the units of the variable
            extract to these units given (see convert in ILAMB.constants)

        Returns
        -------
        var : ILAMB.Variable.Variable
            the requested variable
        """
        t,var,unit,lat,lon = il.ExtractTimeSeries("%s/gpp.nc" % self.path,"gpp")
        if output_unit is not None:
            try:
                var *= convert["gpp"][output_unit][unit]
                unit = output_unit
            except:
                msg  = "The gpp variable is in units of [%s]. " % unit
                msg += "You asked for units of [%s] but I do not know how to convert" % output_unit
                raise il.UnknownUnit(msg)
        return Variable(var,unit,time=t,lat=lat,lon=lon,name="gpp")

    def confront(self,m):
        r"""Confronts the input model with the observational data.

        Parameters
        ----------
        m : ILAMB.ModelResult.ModelResult
            the model results
        """
        # If the model data doesn't have both cell areas and land
        # fractions, we can't do area integrations
        if m.cell_areas is None or m.land_fraction is None:
            msg  = "The %s model cannot perform the %s confrontation " % (m.name,self.name)
            msg += "because it does not have either areas or land fractions"
            raise il.AreasNotInModel(msg)

        # write confrontation result file
        f = Dataset("%s/%s_%s.nc" % (self.output_path,self.name,m.name),mode="w")

        # some data we will store to send to plot routine
        cdata = {}

        # get the observational data
        obs_gpp = self.getData(output_unit="g m-2 s-1")

        # time limits for this confrontation (with a little padding)
        t0,tf = obs_gpp.time.min()-7,obs_gpp.time.max()+7
        ndays = tf-t0
        
        # get the model data
        mod_gpp = m.extractTimeSeries("gpp",initial_time=t0,final_time=tf,
                                      output_unit="g m-2 s-1")
        
        # ensure that oceans are properly masked
        mod_gpp.data = np.ma.masked_array(mod_gpp.data,
                                          mask=mod_gpp.data.mask+(m.land_fraction<1e-2)[np.newaxis,:,:],
                                          copy=False)

        # integrate in time
        plot_benchmark = False
        if self.data.has_key("timeint_gpp"):
            obs_timeint_gpp          = self.data["timeint_gpp"]
        else:
            obs_timeint_gpp          = obs_gpp.integrateInTime(mean=True)
            self.data["timeint_gpp"] = obs_timeint_gpp
            plot_benchmark           = True
        mod_timeint_gpp = mod_gpp.integrateInTime(mean=True)
        mod_timeint_gpp.toNetCDF4(f)

        # diff map of the time integrated gpp
        bias = obs_timeint_gpp.spatialDifference(mod_timeint_gpp)
        bias.name = "bias_of_gpp_integrated_over_time_and_divided_by_time_period"
        bias.toNetCDF4(f)

        # regional analysis
        self.data["spaceint_gpp"] = {}
        self.data["cycle_gpp"   ] = {}
        cdata    ["spaceint_gpp"] = {}
        cdata    ["cycle_gpp"   ] = {}
        for region in self.regions:
            
            # integrate in space
            if self.data["spaceint_gpp"].has_key(region):
                obs_spaceint_gpp = self.data["spaceint_gpp"][region]
            else:
                obs_spaceint_gpp = obs_gpp.integrateInSpace(region=region).convert("Pg y-1")
                self.data["spaceint_gpp"][region] = obs_spaceint_gpp 
            mod_spaceint_gpp = mod_gpp.integrateInSpace(region=region).convert("Pg y-1")
            cdata["spaceint_gpp"][region] = mod_spaceint_gpp
            mod_spaceint_gpp.toNetCDF4(f)

            # metrics go straight to the output file
            mod_spaceint_gpp.integrateInTime(mean=True).convert("Pg y-1").toNetCDF4(f)
            obs_spaceint_gpp.bias(mod_spaceint_gpp)                      .toNetCDF4(f)
            obs_spaceint_gpp.bias(mod_spaceint_gpp,normalize="score")    .toNetCDF4(f)
            obs_spaceint_gpp.RMSE(mod_spaceint_gpp)                      .toNetCDF4(f)
            obs_spaceint_gpp.RMSE(mod_spaceint_gpp,normalize="score")    .toNetCDF4(f)

            # annual cycle
            if self.data["cycle_gpp"].has_key(region):
                obs_cycle_gpp = self.data["cycle_gpp"][region]
            else:
                obs_cycle_gpp,obs_tmax,obs_tmaxstd = obs_spaceint_gpp.annualCycle()
                self.data["cycle_gpp"][region] = obs_cycle_gpp 
            mod_cycle_gpp,mod_tmax,mod_tmaxstd = mod_spaceint_gpp.annualCycle()
            cdata["cycle_gpp"][region] = mod_cycle_gpp
            mod_cycle_gpp.toNetCDF4(f)

        # phase
        if self.data.has_key("phase_gpp"):
            obs_phase_gpp = self.data["phase_gpp"]
        else:
            obs_phase_gpp = obs_gpp.phase()
            self.data["phase_gpp"] = obs_phase_gpp    
        mod_phase_gpp = mod_gpp.phase()
        shift = obs_phase_gpp.spatialDifference(mod_phase_gpp)
        cdata["phase_gpp"] = mod_phase_gpp
        cdata["shift_gpp"] = shift
        mod_phase_gpp.toNetCDF4(f)
        shift.toNetCDF4(f)

        f.close()

        # plotting
        if plot_benchmark: self.plot()
        self.plot(m,cdata)

    def plotFromFiles(self):
        """
        * fix html
        """

        # Load the cycle data for a composite plot
        cycle_gpp  = {}
        mname = "Benchmark"
        cycle_gpp[mname] = {}
        for region in self.regions:
            cycle_gpp[mname][region] = self.data["cycle_gpp"][region] 

        # Load data and track maxima for plotting limits
        gppmax      = self.data["timeint_gpp"].data.max()
        biasmax     = 0
        timeint_gpp = {}
        bias_gpp    = {}
        metrics     = {}
        pattern     = "%s/%s*.nc" % (self.output_path,self.name)
        for fname in glob.glob(pattern):

            mname = fname[:-3].split("_")[-1]

            timeint_gpp[mname] = FromNetCDF4(fname,"gpp_integrated_over_time_and_divided_by_time_period")
            gppmax = max(gppmax,timeint_gpp[mname].data.max())

            bias_gpp[mname] = FromNetCDF4(fname,"bias_of_gpp_integrated_over_time_and_divided_by_time_period")
            biasmax = max(biasmax,np.abs(bias_gpp[mname].data).max())

            cycle_gpp[mname] = {}
            metrics  [mname] = {}
            for region in self.regions:
                cycle_gpp[mname][region] = FromNetCDF4(fname,"annual_cycle_of_gpp_integrated_over_%s" % region)
                metrics[mname][region]   = {}
                metrics[mname][region]["Bias"]      = FromNetCDF4(fname,"bias_of_gpp_integrated_over_%s" % (region))
                metrics[mname][region]["BiasScore"] = FromNetCDF4(fname,"bias_score_of_gpp_integrated_over_%s" % (region))
                metrics[mname][region]["RMSE"]      = FromNetCDF4(fname,"rmse_of_gpp_integrated_over_%s" % (region))
                metrics[mname][region]["RMSEScore"] = FromNetCDF4(fname,"rmse_score_of_gpp_integrated_over_%s" % (region))

        for region in self.regions:

            # plot benchmark time integrated mean
            fig   = plt.figure(figsize=(6.8,2.8))
            ax    = fig.add_axes([0.06,0.025,0.88,0.965])
            self.data["timeint_gpp"].plot(ax,region=region,vmin=0,vmax=gppmax,cmap="Greens")
            fig.savefig("%s/Benchmark_%s_timeint.png" % (self.output_path,region))
            plt.close()

            for key in timeint_gpp.keys():

                # plot model time integrated mean
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                timeint_gpp[key].plot(ax,region=region,vmin=0,vmax=gppmax,cmap="Greens")
                fig.savefig("%s/%s_%s_timeint.png" % (self.output_path,key,region))
                plt.close()

                # plot bias of time integrated mean
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                bias_gpp[key].plot(ax,region=region,vmin=-biasmax,vmax=+biasmax,cmap="seismic")
                fig.savefig("%s/%s_%s_bias.png" % (self.output_path,key,region))
                plt.close()

            # plot composite annual cycle 
            fig = plt.figure(figsize=(6.8,2.8))
            ax  = fig.add_axes([0.06,0.025,0.88,0.965])
            cycle_gpp["Benchmark"][region].std = None
            cycle_gpp["Benchmark"][region].plot(ax,lw=2,alpha=0.25,color='k',label="Obs")
            models = cycle_gpp.keys(); models.remove("Benchmark")
            models = sorted(models,key=lambda key: key.upper())
            clrs   = il.GenerateDistinctColors(len(models))
            for key in models: cycle_gpp[key][region].plot(ax,color=clrs.pop(0),label=key)
            ax.set_xlim(1850.,11./365.+1850)
            ax.set_xticks(np.arange(12)/365.+1850)
            ax.set_xticklabels(["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"])
            ax.set_ylabel(cycle_gpp["Benchmark"][cycle_gpp["Benchmark"].keys()[0]].unit)
            handles, labels = ax.get_legend_handles_labels()
            lgd = ax.legend(handles, labels, loc='upper center', bbox_to_anchor=(1.2,1.0))
            fig.savefig("%s/%s_compcycle.png" % (self.output_path,region),
                        bbox_extra_artists=(lgd,), bbox_inches='tight')
            plt.close()

        # legend
        fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
        post.ColorBar(ax,vmin=0,vmax=gppmax,cmap="Greens",label=timeint_gpp[timeint_gpp.keys()[0]].unit)
        fig.savefig("%s/legend_timeint.png" % (self.output_path))
        plt.close()

        # legend
        fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
        post.ColorBar(ax,vmin=-biasmax,vmax=+biasmax,
                      cmap="seismic",label=bias_gpp[bias_gpp.keys()[0]].unit)
        fig.savefig("%s/legend_bias.png" % (self.output_path))
        plt.close()

        # write the html output file
        f = file("%s/%s.html" % (self.output_path,self.name),"w")
        f.write(post.ConfrontationTableGoogle(self,metrics))
        f.close()

    def plot(self,m=None,data=None):

        if m is None:

            # phase legend
            fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
            post.ColorBar(ax,vmin=0,vmax=365.,ticks=mid_months,cmap="jet",label="month",
                          ticklabels=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"])
            fig.savefig("%s/legend_phase.png" % (self.output_path))
            plt.close()
        
            # shift legend
            fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
            post.ColorBar(ax,vmin=-0.5*365.,vmax=+0.5*365.,cmap="PRGn",label="month",
                          ticks=np.linspace(-0.5*365,+0.5*365,13),ticklabels=range(-6,7))
            fig.savefig("%s/legend_shift.png" % (self.output_path))
            plt.close()

            for region in self.regions:            

                # benchmark phase info
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                self.data["phase_gpp"].plot(ax,vmin=0,vmax=365.,region=region,cmap="jet")
                fig.savefig("%s/Benchmark_%s_phase.png" % (self.output_path,region))
                plt.close()

        else:

            assert data is not None
            for region in self.regions:

                # model space integrated mean compared to benchmark
                fig = plt.figure(figsize=(6.8,2.8*0.8))
                ax  = fig.add_axes([0.06,0.025,0.88,0.965])
                self.data["spaceint_gpp"][region].plot(ax,lw=2,alpha=0.25,color='k',label="Obs")
                data["spaceint_gpp"][region].plot(ax,color=m.color,label=m.name)
                ax.set_xlabel("Year")
                ax.set_ylabel(data["spaceint_gpp"][region].unit)
                handles, labels = ax.get_legend_handles_labels()
                lgd = ax.legend(handles, labels, ncol=2, loc='upper center', bbox_to_anchor=(0.5,1.2))
                fig.savefig("%s/%s_%s_spaceint.png" % (self.output_path,m.name,region),
                            bbox_extra_artists=(lgd,), bbox_inches='tight')
                plt.close()

                # model annual cycle compared to benchmark
                fig = plt.figure(figsize=(6.8,2.8*0.8))
                ax  = fig.add_axes([0.06,0.025,0.88,0.965])
                self.data["cycle_gpp"][region].plot(ax,lw=2,alpha=0.25,color='k',label="Obs")
                data["cycle_gpp"][region].plot(ax,color=m.color,label=m.name)
                ax.set_xlim(1850.,11./365.+1850)
                ax.set_xticks(np.arange(12)/365.+1850)
                ax.set_xticklabels(["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"])
                ax.set_ylabel(data["cycle_gpp"][region].unit)
                handles, labels = ax.get_legend_handles_labels()
                lgd = ax.legend(handles, labels, ncol=2, loc='upper center', bbox_to_anchor=(0.5,1.2))
                fig.savefig("%s/%s_%s_cycle.png" % (self.output_path,m.name,region),
                            bbox_extra_artists=(lgd,), bbox_inches='tight')
                plt.close()

                # model phase info
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                data["phase_gpp"].plot(ax,region=region,cmap="jet")
                fig.savefig("%s/%s_%s_phase.png" % (self.output_path,m.name,region))
                plt.close()

                # model shift info
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                data["shift_gpp"].plot(ax,vmin=-0.5*365.,vmax=+0.5*365.,region=region,cmap="PRGn")
                fig.savefig("%s/%s_%s_shift.png" % (self.output_path,m.name,region))
                plt.close()
