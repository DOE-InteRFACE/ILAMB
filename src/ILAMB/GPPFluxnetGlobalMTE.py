from netCDF4 import Dataset
import numpy as np
import pylab as plt
import ilamblib as il
from constants import convert,spd,mid_months,lbl_months
import Post as post
import os,glob,re
from Variable import Variable,FromNetCDF4

def _ForrestsTickMarks(ax,per=0.05):
    yticks = ax.get_yticks()
    pad    = per*(yticks[-1]-yticks[0])
    ax.set_ylim(yticks[0]-pad,yticks[-1]+pad)
    ax.set_yticks(yticks)

def _ShiftYearTicks(ax):
    xt  = ax.get_xticks()
    xtl = ["%d" % x for x in xt]
    xt  = np.asarray(xt)+0.5
    ax.set_xlim(xt[0]-0.5,xt[1]+0.5)
    ax.xaxis.set_ticks(np.arange(xt[0],xt[-1]+1),minor=True)
    ax.xaxis.set_ticks(xt                       ,minor=False)
    ax.set_xticklabels(xtl)

def _UnitStringToMatplotlib(unit):
    # raise exponents using Latex
    match = re.findall("(-\d)",unit)
    for m in match: unit = unit.replace(m,"$^{%s}$" % m)
    # add carbon symbol to all mass units
    match = re.findall("(\D*g)",unit)
    for m in match: unit = unit.replace(m,"%s C " % m)
    return unit

class GPPFluxnetGlobalMTE():
    """Confront models with the gross primary productivity (GPP) product
    generated by Fluxnet MTE.
    """
    def __init__(self):
        self.name = "GPPFluxnetGlobalMTE"
        self.path = os.environ["ILAMB_ROOT"] + "/DATA/gpp/FLUXNET-MTE/derived/"
        try:
            os.stat(self.path)
        except:
            msg  = "I am looking for data for the %s confrontation here\n\n" % self.name
            msg += "%s\n\nbut I cannot find it. " % self.path
            msg += "Did you download the data? Have you set the ILAMB_ROOT envronment variable?"
            raise il.MisplacedData(msg)
        self.data = {}
        self.regions = ["global","amazon"] #,"bona","tena","ceam","nhsa","shsa"]

        # build output path if not already built
        self.output_path = "_build/GPPFluxnetGlobalMTE"
        dirs = self.output_path.split("/")
        for i,d in enumerate(dirs):
            dname = "/".join(dirs[:(i+1)])
            if not os.path.isdir(dname): os.mkdir(dname)

        # somewhat complicated layout designation for HTML output pages
        self.layout = []
        self.layout.append({"name" :"Temporally integrated period mean",
                            "plots":{"timeint" :["MEAN",True],
                                     "bias"    :["BIAS",True]}})
        self.layout.append({"name" :"Spatially integrated regional mean",
                            "plots":{"spaceint":["MEAN",False]}})
        self.layout.append({"name" :"Spatial Distribution",
                            "plots":{"spatial_variance":["SPACE",False]}})        
        self.layout.append({"name" :"Annual cycle",
                            "plots":{"cycle"    :["CYCLE",True],
                                     "compcycle":["COMP",False]}})
        self.layout.append({"name" :"Phase",
                            "plots":{"phase"   :["PEAK",True],
                                     "shift"   :["SHIFT",True]}})

        # how do metrics get blended?
        self.weights = {"RMSEScore"         :2.,
                        "BiasScore"         :1.,
                        "SeasonalCycleScore":1.}
        
    def getData(self,output_unit=None):
        """Retrieves the confrontation data in the desired unit.

        Parameters
        ----------
        output_unit : string, optional
            if specified, will try to convert the units of the variable
            extract to these units given (see convert in ILAMB.constants)

        Returns
        -------
        var : ILAMB.Variable.Variable
            the requested variable
        """
        t,var,unit,lat,lon = il.ExtractTimeSeries("%s/gpp.nc" % self.path,"gpp")
        if output_unit is not None:
            try:
                var *= convert["gpp"][output_unit][unit]
                unit = output_unit
            except:
                msg  = "The gpp variable is in units of [%s]. " % unit
                msg += "You asked for units of [%s] but I do not know how to convert" % output_unit
                raise il.UnknownUnit(msg)
        return Variable(var,unit,time=t,lat=lat,lon=lon,name="gpp")

    def confront(self,m):
        r"""Confronts the input model with the observational data.

        Parameters
        ----------
        m : ILAMB.ModelResult.ModelResult
            the model results
        """
        # If the model data doesn't have both cell areas and land
        # fractions, we can't do area integrations
        if m.cell_areas is None or m.land_fraction is None:
            msg  = "The %s model cannot perform the %s confrontation " % (m.name,self.name)
            msg += "because it does not have either areas or land fractions"
            raise il.AreasNotInModel(msg)

        # write confrontation result file
        f = Dataset("%s/%s_%s.nc" % (self.output_path,self.name,m.name),mode="w")

        # some data we will store to send to plot routine
        cdata = {}

        # get the observational data
        obs_gpp = self.getData(output_unit="g m-2 s-1")

        # time limits for this confrontation (with a little padding)
        t0,tf = obs_gpp.time.min()-7,obs_gpp.time.max()+7
        ndays = tf-t0
        
        # get the model data
        mod_gpp = m.extractTimeSeries("gpp",initial_time=t0,final_time=tf,
                                      output_unit="g m-2 s-1")
        
        # ensure that oceans are properly masked
        mod_gpp.data = np.ma.masked_array(mod_gpp.data,
                                          mask=mod_gpp.data.mask+(mod_gpp.area<1e-2)[np.newaxis,:,:],
                                          copy=False)

        # integrate in time
        plot_benchmark = False
        if self.data.has_key("timeint_gpp"):
            obs_timeint_gpp          = self.data["timeint_gpp"]
        else:
            obs_timeint_gpp          = obs_gpp.integrateInTime(mean=True)
            self.data["timeint_gpp"] = obs_timeint_gpp
            plot_benchmark           = True
        mod_timeint_gpp = mod_gpp.integrateInTime(mean=True)
        mod_timeint_gpp.toNetCDF4(f)

        # interpolate to a composed grid
        lat,lon = obs_timeint_gpp.composeGrids(mod_timeint_gpp)
        I_obs_timeint_gpp = obs_timeint_gpp.interpolateSpatial(lat,lon)
        I_mod_timeint_gpp = mod_timeint_gpp.interpolateSpatial(lat,lon)

        # diff map of the time integrated gpp
        bias = I_obs_timeint_gpp.spatialDifference(I_mod_timeint_gpp)
        bias.name = "bias_of_gpp_integrated_over_time_and_divided_by_time_period"
        bias.toNetCDF4(f)

        # phase
        if self.data.has_key("phase_gpp"):
            obs_phase_gpp = self.data["phase_gpp"]
        else:
            obs_phase_gpp = obs_gpp.phase()
            self.data["phase_gpp"] = obs_phase_gpp    
        mod_phase_gpp = mod_gpp.phase()

        # shift, the shift can only be on the interval [-6,6] months
        shift = obs_phase_gpp.spatialDifference(mod_phase_gpp)
        shift.data += (shift.data < -0.5*365)*365.
        shift.data -= (shift.data > +0.5*365)*365.
        cdata["phase_gpp"] = mod_phase_gpp
        cdata["shift_gpp"] = shift
        mod_phase_gpp.toNetCDF4(f)
        shift.toNetCDF4(f)

        # regional analysis
        self.data["spaceint_gpp"] = {}
        self.data["cycle_gpp"   ] = {}
        self.data["tmax"        ] = {}
        self.data["tstd"        ] = {}
        cdata    ["spaceint_gpp"] = {}
        cdata    ["cycle_gpp"   ] = {}
        cdata    ["tmax"        ] = {}
        cdata    ["tstd"        ] = {}
        for region in self.regions:
            
            # integrate in space
            if self.data["spaceint_gpp"].has_key(region):
                obs_spaceint_gpp = self.data["spaceint_gpp"][region]
            else:
                obs_spaceint_gpp = obs_gpp.integrateInSpace(region=region).convert("Pg y-1")
                self.data["spaceint_gpp"][region] = obs_spaceint_gpp 
            mod_spaceint_gpp = mod_gpp.integrateInSpace(region=region).convert("Pg y-1")
            cdata["spaceint_gpp"][region] = mod_spaceint_gpp
            mod_spaceint_gpp.toNetCDF4(f)

            # spatial variation
            cor,std = I_obs_timeint_gpp.corrcoef(I_mod_timeint_gpp,region=region)
            Variable(np.ma.masked_array(cor),"-",name="correlation_%s" % region).toNetCDF4(f)
            Variable(np.ma.masked_array(std),"-",name="std_%s" % region)        .toNetCDF4(f)

            # metrics go straight to the output file
            mod_spaceint_gpp.integrateInTime(mean=True).convert("Pg y-1").toNetCDF4(f)
            obs_spaceint_gpp.bias(mod_spaceint_gpp)                      .toNetCDF4(f)
            obs_spaceint_gpp.bias(mod_spaceint_gpp,normalize="score")    .toNetCDF4(f)
            obs_spaceint_gpp.RMSE(mod_spaceint_gpp)                      .toNetCDF4(f)
            obs_spaceint_gpp.RMSE(mod_spaceint_gpp,normalize="score")    .toNetCDF4(f)

            # annual cycle
            if not self.data["cycle_gpp"].has_key(region):
                obs_cycle_gpp,obs_tmax,obs_tmaxstd = obs_spaceint_gpp.annualCycle()
                self.data["cycle_gpp"][region] = obs_cycle_gpp 
                self.data["tmax"]     [region] = obs_tmax
                self.data["tstd"]     [region] = obs_tmaxstd
            mod_cycle_gpp,mod_tmax,mod_tmaxstd = mod_spaceint_gpp.annualCycle()
            cdata["cycle_gpp"][region] = mod_cycle_gpp
            cdata["tmax"]     [region] = mod_tmax
            cdata["tstd"]     [region] = mod_tmaxstd
            mod_cycle_gpp.toNetCDF4(f)

            # shift
            shift.integrateInSpace(region=region,mean=True).toNetCDF4(f)

            # seasonal cycle phase metric
            cycle = (1-np.cos(np.abs(shift.data)/365*2*np.pi))*0.5
            Variable(cycle,"-",
                     name = "seasonal_cycle_score",
                     lat  = shift.lat,
                     lon  = shift.lon,
                     area = shift.area).integrateInSpace(region=region,mean=True).toNetCDF4(f)
  
        f.close()

        # plotting
        if plot_benchmark: self.plot()
        self.plot(m,cdata)

    def plotFromFiles(self):
        """
        """

        # Load the cycle data for a composite plot
        cycle_gpp  = {}
        mname = "Benchmark"
        cycle_gpp[mname] = {}
        for region in self.regions:
            cycle_gpp[mname][region] = self.data["cycle_gpp"][region] 

        cor = {}
        std = {}
        # Setup Taylor diagram
        for region in self.regions:
            cor[region] = []
            std[region] = []

        # Load data and track maxima for plotting limits
        gppmax      = self.data["timeint_gpp"].data.max()
        biasmax     = 0
        timeint_gpp = {}
        bias_gpp    = {}
        metrics     = {}
        pattern     = "%s/%s*.nc" % (self.output_path,self.name)
        for fname in glob.glob(pattern):

            mname = fname[:-3].split("_")[-1]

            timeint_gpp[mname] = FromNetCDF4(fname,"gpp_integrated_over_time_and_divided_by_time_period")
            gppmax = max(gppmax,timeint_gpp[mname].data.max())

            bias_gpp[mname] = FromNetCDF4(fname,"bias_of_gpp_integrated_over_time_and_divided_by_time_period")
            biasmax = max(biasmax,np.abs(bias_gpp[mname].data).max())

            cycle_gpp[mname] = {}
            metrics  [mname] = {}
            for region in self.regions:
                cycle_gpp[mname][region] = FromNetCDF4(fname,"annual_cycle_of_gpp_integrated_over_%s" % region)
                metrics[mname][region]   = {}
                metrics[mname][region]["PeriodMean"] = FromNetCDF4(fname,"gpp_integrated_over_%s_integrated_over_time_and_divided_by_time_period" % region)
                metrics[mname][region]["Bias"]       = FromNetCDF4(fname,"bias_of_gpp_integrated_over_%s" % region)
                metrics[mname][region]["BiasScore"]  = FromNetCDF4(fname,"bias_score_of_gpp_integrated_over_%s" % region)
                metrics[mname][region]["RMSE"]       = FromNetCDF4(fname,"rmse_of_gpp_integrated_over_%s" % region)
                metrics[mname][region]["RMSEScore"]  = FromNetCDF4(fname,"rmse_score_of_gpp_integrated_over_%s" % region)
                metrics[mname][region]["PhaseShift"] = FromNetCDF4(fname,"day_of_max_gpp_minus_day_of_max_gpp_integrated_over_%s" % region)
                metrics[mname][region]["SeasonalCycleScore"] = FromNetCDF4(fname,"seasonal_cycle_score_integrated_over_%s" % region)
                
                score = 0.
                sumw  = 0.
                for key in self.weights.keys():
                    score += self.weights[key]*metrics[mname][region][key].data
                    sumw  += self.weights[key]
                score = np.ma.masked_array(score/sumw)
                metrics[mname][region]["OverallScore"] = Variable(score,"-",name="overall_score")
                               
                cor[region].append(FromNetCDF4(fname,"correlation_%s" % region).data.data)     
                std[region].append(FromNetCDF4(fname,"std_%s"         % region).data.data)     

        for region in self.regions:

            # plot benchmark time integrated mean
            fig   = plt.figure(figsize=(6.8,2.8))
            ax    = fig.add_axes([0.06,0.025,0.88,0.965])
            self.data["timeint_gpp"].plot(ax,region=region,vmin=0,vmax=gppmax,cmap="Greens")
            fig.savefig("%s/Benchmark_%s_timeint.png" % (self.output_path,region))
            plt.close()

            # 
            fig = plt.figure(figsize=(7.5,7.5))
            models = cycle_gpp.keys(); models.remove("Benchmark")
            models = sorted(models,key=lambda key: key.upper())
            clrs   = il.GenerateDistinctColors(len(models))
            post.TaylorDiagram(np.asarray(std[region]),np.asarray(cor[region]),1.0,
                               fig,clrs,normalize=False)
            fig.savefig("%s/%s_spatial_variance.png" % (self.output_path,region))
            plt.close()

            for key in timeint_gpp.keys():

                # plot model time integrated mean
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                timeint_gpp[key].plot(ax,region=region,vmin=0,vmax=gppmax,cmap="Greens")
                fig.savefig("%s/%s_%s_timeint.png" % (self.output_path,key,region))
                plt.close()

                # plot bias of time integrated mean
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                bias_gpp[key].plot(ax,region=region,vmin=-biasmax,vmax=+biasmax,cmap="seismic")
                fig.savefig("%s/%s_%s_bias.png" % (self.output_path,key,region))
                plt.close()

            # plot composite annual cycle 
            fig,ax = plt.subplots(figsize=(6.8,2.8),tight_layout=True)
            cycle_gpp["Benchmark"][region].std = None
            cycle_gpp["Benchmark"][region].plot(ax,lw=3,alpha=0.25,color='k',label="Obs")
            for key in models: cycle_gpp[key][region].plot(ax,lw=2,color=clrs.pop(0),label=key)
            ax.set_xlim(1850,1851) 
            ax.set_xticks(1850+mid_months/365.) 
            ax.set_xticklabels(lbl_months)
            ax.set_ylabel(_UnitStringToMatplotlib(cycle_gpp["Benchmark"][cycle_gpp["Benchmark"].keys()[0]].unit))
            _ForrestsTickMarks(ax)
            fig.savefig("%s/%s_compcycle.png" % (self.output_path,region))
            plt.close()

        # cycle legend
        H,L    = ax.get_legend_handles_labels()
        fig,ax = plt.subplots(figsize=(6.8,2.8),tight_layout=True)
        ax.legend(H,L,loc="upper left",ncol=3,fontsize=10)
        ax.axis('off')
        fig.savefig("%s/legend_cycle.png" % self.output_path)
        
        # timeint legend
        fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
        post.ColorBar(ax,vmin=0,vmax=gppmax,cmap="Greens",label=_UnitStringToMatplotlib(timeint_gpp[timeint_gpp.keys()[0]].unit))
        fig.savefig("%s/legend_timeint.png" % (self.output_path))
        plt.close()

        # bias legend
        fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
        post.ColorBar(ax,vmin=-biasmax,vmax=+biasmax,
                      cmap="seismic",label=_UnitStringToMatplotlib(bias_gpp[bias_gpp.keys()[0]].unit))
        fig.savefig("%s/legend_bias.png" % (self.output_path))
        plt.close()

        # write the html output file
        f = file("%s/%s.html" % (self.output_path,self.name),"w")
        f.write(post.ConfrontationTableGoogle(self,metrics))
        f.close()

    def plot(self,m=None,data=None):

        if m is None:

            # phase legend
            fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
            post.ColorBar(ax,vmin=0,vmax=365.,ticks=mid_months,cmap="jet",label="month",
                          ticklabels=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"])
            fig.savefig("%s/legend_phase.png" % (self.output_path))
            plt.close()
        
            # shift legend
            fig,ax = plt.subplots(figsize=(6.8,1.0),tight_layout=True)
            post.ColorBar(ax,vmin=-0.5*365.,vmax=+0.5*365.,cmap="PRGn",label="month",
                          ticks=np.linspace(-0.5*365,+0.5*365,13),ticklabels=range(-6,7))
            fig.savefig("%s/legend_shift.png" % (self.output_path))
            plt.close()

            for region in self.regions:            

                # benchmark phase info
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                self.data["phase_gpp"].plot(ax,vmin=0,vmax=365.,region=region,cmap="jet")
                fig.savefig("%s/Benchmark_%s_phase.png" % (self.output_path,region))
                plt.close()

        else:

            assert data is not None
            for region in self.regions:

                # model space integrated mean compared to benchmark
                fig,ax = plt.subplots(figsize=(6.8,2.8),tight_layout=True)
                self.data["spaceint_gpp"][region].plot(ax,lw=3,alpha=0.25,color='k',label="Obs")
                data["spaceint_gpp"][region].plot(ax,lw=2,color=m.color,label=m.name)
                ax.set_xlabel("Year")
                ax.set_ylabel(_UnitStringToMatplotlib(data["spaceint_gpp"][region].unit))
                _ShiftYearTicks(ax)
                _ForrestsTickMarks(ax)
                fig.savefig("%s/%s_%s_spaceint.png" % (self.output_path,m.name,region))
                plt.close()

                # model annual cycle compared to benchmark
                fig,ax = plt.subplots(figsize=(6.8,2.8),tight_layout=True)
                self.data["cycle_gpp"][region].plot(ax,lw=2,alpha=0.25,color='k',label="Obs")
                ax.errorbar(self.data["tmax"][region]/365.+1850,
                            self.data["cycle_gpp"][region].data.max(),
                            xerr=self.data["tstd"][region]/365.,fmt='o',color='k',lw=2,alpha=0.25)
                data["cycle_gpp"][region].plot(ax,lw=2,color=m.color,label=m.name)
                ax.errorbar(data["tmax"][region]/365.+1850,
                            data["cycle_gpp"][region].data.max(),
                            xerr=data["tstd"][region]/365.,fmt='o',color=m.color,lw=2)
                ax.set_xlim(1850,1851) 
                ax.set_xticks(1850+mid_months/365.) 
                ax.set_xticklabels(lbl_months)
                ax.set_ylabel(_UnitStringToMatplotlib(data["cycle_gpp"][region].unit))
                _ForrestsTickMarks(ax)
                fig.savefig("%s/%s_%s_cycle.png" % (self.output_path,m.name,region))
                plt.close()

                # model phase info
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                data["phase_gpp"].plot(ax,region=region,cmap="jet")
                fig.savefig("%s/%s_%s_phase.png" % (self.output_path,m.name,region))
                plt.close()

                # model shift info
                fig   = plt.figure(figsize=(6.8,2.8))
                ax    = fig.add_axes([0.06,0.025,0.88,0.965])
                data["shift_gpp"].plot(ax,vmin=-0.5*365.,vmax=+0.5*365.,region=region,cmap="PRGn")
                fig.savefig("%s/%s_%s_shift.png" % (self.output_path,m.name,region))
                plt.close()
